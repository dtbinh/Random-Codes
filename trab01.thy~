theory labPrimRec
imports Main
begin

datatype Nat = Z | suc Nat

primrec add::"Nat => Nat => Nat" where
  "add x Z = x" |
  "add x (suc y) = suc (add x y)"

primrec Nat2int::"Nat => int" where
  "Nat2int Z = 0" |
  "Nat2int (suc y) = Nat2int(y) + 1"

datatype 'a List = nil | cons 'a "'a List"

primrec len::"'a List => Nat" where
  "len nil = Z" |
  "len (cons y list) = suc (len list)"

primrec cat::"'a List => 'a List => 'a List" where
  "cat nil list= list" |
  "cat (cons e list1) list2 = (cons e (cat list1 list2))"

primrec delete::"'a => 'a List => 'a List" where
  "delete x nil = nil" |
  "delete x (cons e L) = (if x = e then delete x L else cons e (delete x L))"

primrec revert::"'a List => 'a List" where
  "revert nil = nil" |
  "revert (cons e L) = cat (revert L) (cons e nil)"

datatype 'a btree = leaf | br 'a "'a btree" "'a btree"

primrec numLeaf::"'a btree => Nat" where
  "numLeaf leaf = suc Z" |
  "numLeaf (br x left right) = add (numLeaf left) (numLeaf right)"

primrec numNodos::"'a btree => Nat" where
  "numNodos leaf = Z" |
  "numNodos (br x left right) = suc (add (numNodos left) (numNodos right))"

primrec depth::"'a btree => int" where
  "depth leaf = 0" |
  "depth (br x left right) = (max (depth left) (depth right)) + 1"

primrec inorder::"'a btree => 'a List" where
  "inorder leaf = nil" |
  "inorder (br x left right) = cat (inorder left) (cons x (inorder right))"

value "inorder (br (3::int) (br 4 (br 6 leaf leaf) leaf) (br 5 leaf leaf))"

primrec postorder::"'a btree => 'a List" where
  "postorder leaf = nil" |
  "postorder (br x left right) = cat (postorder left) (cat (postorder right) (cons x nil))"

value "postorder (br (3::int) (br 4 (br 6 leaf leaf) leaf) (br 5 leaf leaf))"

primrec preorder::"'a btree => 'a List" where
  "preorder leaf = nil" |
  "preorder (br x left right) = cons x (cat (preorder left) (preorder right))"

value "preorder (br (3::int) (br 4 (br 6 leaf leaf) leaf) (br 5 leaf leaf))"

primrec reflect::"'a btree => 'a btree" where
  re01: "reflect leaf = leaf" |
  re02: "reflect (br x left right) = (br x (reflect right) (reflect left))"

value "reflect (br (3::int) (br 4 leaf leaf) (br 5 leaf leaf))"

theorem th01: "postorder (reflect x) = revert (preorder x)"
  proof (induction x)
    show "postorder (reflect leaf) = revert (preorder leaf)"
      have "postorder (reflect leaf) = postorder leaf" by (simp)
      also have "... = nil" by (simp)
      also have "... = revert nil" by (simp)
      also have "... = revert (preorder leaf)" by (simp)
    next
oops

end
